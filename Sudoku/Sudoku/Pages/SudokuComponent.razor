@using Sudoku.Classes;
@inject SweetAlertService Swal;
<div class="sudoku-inputs">
	<div hidden = "@(sudoku!=null)">
		<label>
			Upload a sudoku:
			<InputFile class="button-purple" OnChange="@OnInputFileChanged"/>
		</label>
	</div>
	<br/>
	<button class="button-purple" hidden ="@(sudoku==null)" disabled="@(!inactive)" @onclick="Start">Start</button>
	<!--<button class="button-purple" hidden="@inactive" @onclick="SolveSudoku">Solve</button>-->
	<button class="button-purple" hidden="@inactive" @onclick="ResetSudoku">Reset</button>
	<button class="button-purple" hidden="@inactive" disabled="@(!sudoku?.SolvingProzessFinished)" @onclick="GetHint">Hint</button>
	<button class="button-purple" hidden="@inactive" disabled="@(!sudoku?.SolvingProzessFinished)" @onclick="GetResult">End</button>
	<br/>
</div>
<div hidden ="@(!isRunning)" class="timer-container">Time: @timeSpan.ToString(@"hh\:mm\:ss")</div>
<section class="board">
	@{
		if (sudoku != null)
		{
			for (int i = 0; i < sudoku.Board.GetLength(0); i++)
			{
				for (int j = 0; j < sudoku.Board.GetLength(1); j++)
				{
					int currentRowIdx = i;
					int currentColIdx = j;
					string cssClassTag = "tile";

					if (i == 0)
					{
						cssClassTag += " tile-firstRow";
					}
					if (j == 0)
					{
						cssClassTag += " tile-firstCol";
					}

					<div tabindex="-1" @onkeydown="KeyboardEventHandler" class=@cssClassTag @onclick="() => FieldClicked(currentRowIdx, currentColIdx)">@sudoku.Board[i, j]</div>
				}
			}
		}
	}
</section>

@code {

	private struct Field
	{
		public int RowIdx;
		public int ColIdx;

		public Field(int rowIdx, int colIdx)
		{
			RowIdx = rowIdx;
			ColIdx = colIdx;
		}
	}

	private SudokuCreator sudokuCreator = new SudokuCreator();
	private SudokuSolver sudokuSolver = new SudokuSolver();
	private Sudoku? sudoku = null;

	private Field activeField = new Field(-1, -1);

	private bool inactive = true;
	private bool solutionDisplayed = false;

	#region Helper Methods

	#endregion

	#region Sudoku Methods

	private void KeyboardEventHandler(KeyboardEventArgs args)
	{
		if (sudoku != null && activeField.RowIdx != -1 && activeField.ColIdx != -1)
		{
			string key = args.Key;

			Console.WriteLine("Key Pressed is " + key);
			Console.WriteLine("Event Type " + args.Type);

			int inputNumber;
			if (int.TryParse(key, out inputNumber))
			{
				sudoku.ChangeNumberOfField(activeField.RowIdx, activeField.ColIdx, Convert.ToInt32(args.Key));
			}
		}
	}

	private void FieldClicked(int rowIdx, int colIdx)
	{
		if (sudoku != null && !inactive)
		{
			Console.WriteLine("rowIdx: {0}, colIdx: {1}", rowIdx, colIdx);
			if (sudoku.IsInitialFieldStateFilled(rowIdx, colIdx))
			{
				Console.WriteLine("Can't change field value if its initialy filled");
				activeField.RowIdx = -1;
				activeField.ColIdx = -1;
			}
			else
			{
				activeField.RowIdx = rowIdx;
				activeField.ColIdx = colIdx;
			}
		}
	}
	#endregion

	#region Button Methods

	private async Task OnInputFileChanged(InputFileChangeEventArgs e)
	{
		//check for file type

		var file = e.File;
		long maxsize = 512000;

		var buffer = new byte[file.Size];
		await file.OpenReadStream(maxsize).ReadAsync(buffer);
		string fileContent = System.Text.Encoding.UTF8.GetString(buffer);

		try
		{
			sudoku = sudokuCreator.LoadFromFile(fileContent);
			//await AlertBox.DisplayAlert(Swal, "Press start and try to solve it!");
		}
		catch (Exception ex)
		{
			await AlertBox.DisplayAlert(Swal,ex.Message);
			Console.WriteLine(ex.Message);
		}
	}

	private void ResetSudoku()
	{
		if (sudoku != null)
		{
			sudoku.Reset();
		}
	}

	private async void SolveSudoku()
	{
		if (sudoku != null)
		{
			try
			{
				sudoku.TryUncoverSolution();
			}
			catch (Exception e)
			{
				await AlertBox.DisplayAlert(Swal, e.Message);
				Console.WriteLine(e.Message);
			}
		}
	}

	private async void GetResult()
	{
		if (sudoku != null)
		{
			try
			{
				if (sudoku.IsCorrectSoulution())
				{
					ResetStopwatch();
					await AlertBox.DisplayAlert(Swal, "Correct Solution!\n Your time: " + (int)timeInSeconds + " seconds");
					Console.WriteLine("Correct Solution!");
					inactive = true;
					sudoku.Solved = true;
					InvokeAsync(StateHasChanged);

				}
				else
				{
					//pause
					StopStopwatch();
					var result = await AlertBox.DisplayAlertWithButtons(Swal, "Wrong Solution! Continue or Cancel?", "Continue", "Show Solution");

					//continue
					if (!string.IsNullOrEmpty(result.Value))
					{
						StartStopwatch();
					}
					else
					{
						SolveSudoku();
						ResetStopwatch();
						inactive = true;
						sudoku.Solved = true;
						InvokeAsync(StateHasChanged);
					}

					Console.WriteLine("Wrong Solution!");
				}
			}
			catch (Exception e)
			{
				await AlertBox.DisplayAlert(Swal, e.Message);
				Console.WriteLine(e.Message);
			}
		}
	}

	private async void GetHint()
	{
		if (sudoku != null)
		{
			try
			{
				sudoku.TryUncoverRandomField();
			}
			catch (Exception e)
			{
				await AlertBox.DisplayAlert(Swal, e.Message);
				Console.WriteLine(e.Message);
			}
		}
	}

	private async void Start()
	{
		if (sudoku != null)
		{
			if (sudokuSolver.IsSudokuPossible(sudoku))
			{
				//start generate solution in background
				sudokuSolver.GenerateSolution(sudoku);
				StartStopwatch();
				inactive = false;
			}
			else
			{
				await AlertBox.DisplayAlert(Swal, "Sudoku not possible to solve (dublicate in collumn, row or block)!");
				Console.WriteLine("Sudoku not possible to solve (dublicate in collumn, row or block)!");
			}
		}
	}
	#endregion

	#region StopWatch Component
	private TimeSpan timeSpan;
	private bool isRunning = false;
	private DateTime startTime;
	private Timer timer;
	private double timeInSeconds;

	private void StartStopwatch()
	{
		if (!isRunning)
		{
			startTime = DateTime.Now - timeSpan;
			timer = new Timer(UpdateTime, null, 0, 1000);
			isRunning = true;
		}
	}

	private void UpdateTime(object state)
	{
		timeSpan = DateTime.Now - startTime;
		InvokeAsync(StateHasChanged);
	}

	private void StopStopwatch()
	{
		if (isRunning)
		{
			timer?.Dispose();
			isRunning = false;
		}
	}

	private void ResetStopwatch()
	{
		StopStopwatch();
		timeInSeconds = timeSpan.TotalSeconds;
		timeSpan = TimeSpan.Zero;
	}
	#endregion
}

