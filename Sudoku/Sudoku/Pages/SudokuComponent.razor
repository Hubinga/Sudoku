@using Sudoku.Classes;
@inject SweetAlertService Swal;
<div>
	<button class="button-purple" @onclick="SolveSudoku">Solve</button>
	<button class="button-purple" @onclick="ResetSudoku">Reset</button>
	<button class="button-purple" @onclick="GetHint">Hint</button>
	<button class="button-purple" @onclick="Start">Start</button>
	<button class="button-purple" @onclick="GetResult">End</button>
	<br/>
	<label>
		Upload a sudoku:
		<InputFile class="button-purple" OnChange="@OnInputFileChanged"/>
	</label>
</div>
<section class="board">
	@{
		if (sudoku != null)
		{
			for (int i = 0; i < sudoku.Board.GetLength(0); i++)
			{
				for (int j = 0; j < sudoku.Board.GetLength(1); j++)
				{
					int currentRowIdx = i;
					int currentColIdx = j;
					string cssClassTag = "tile";

					if(i == 0)
					{
						cssClassTag += " tile-firstRow";
					}
					if (j == 0)
					{
						cssClassTag += " tile-firstCol";
					}

					<div tabindex="-1" @onkeydown="KeyboardEventHandler" class=@cssClassTag @onclick="() => FieldClicked(currentRowIdx, currentColIdx)">@sudoku.Board[i, j]</div>
				}
			}
		}
	}
</section>

@code {

	private struct Field
	{
		public int RowIdx;
		public int ColIdx;

		public Field(int rowIdx, int colIdx)
		{
			RowIdx = rowIdx;
			ColIdx = colIdx;
		}
	}

	private SudokuCreator sudokuCreator = new SudokuCreator();
	private SudokuSolver sudokuSolver = new SudokuSolver();
	private Sudoku? sudoku = null;

	private Field activeField = new Field(-1, -1);

	#region Helper Methods

	private async Task DisplayAlert(string message)
	{
		await Swal.FireAsync(message);
	}
	#endregion

	#region Sudoku Methods

	private void KeyboardEventHandler(KeyboardEventArgs args)
	{
		if (sudoku != null && activeField.RowIdx != -1 && activeField.ColIdx != -1)
		{
			string key = args.Key;

			Console.WriteLine("Key Pressed is " + key);
			Console.WriteLine("Event Type " + args.Type);

			int inputNumber;
			if (int.TryParse(key, out inputNumber))
			{
				sudoku.ChangeNumberOfField(activeField.RowIdx, activeField.ColIdx, Convert.ToInt32(args.Key));
			}
		}
	}

	private void FieldClicked(int rowIdx, int colIdx)
	{
		if (sudoku != null)
		{
			Console.WriteLine("rowIdx: {0}, colIdx: {1}", rowIdx, colIdx);
			if (sudoku.IsInitialFieldStateFilled(rowIdx, colIdx))
			{
				Console.WriteLine("Can't change field value if its initialy filled");
				activeField.RowIdx = -1;
				activeField.ColIdx = -1;
			}
			else
			{
				activeField.RowIdx = rowIdx;
				activeField.ColIdx = colIdx;
			}
		}
	}
	#endregion

	#region Button Methods

	private async Task OnInputFileChanged(InputFileChangeEventArgs e)
	{
		//check for file type

		var file = e.File;
		long maxsize = 512000;

		var buffer = new byte[file.Size];
		await file.OpenReadStream(maxsize).ReadAsync(buffer);
		string fileContent = System.Text.Encoding.UTF8.GetString(buffer);

		try
		{
			sudoku = sudokuCreator.LoadFromFile(fileContent);
		}
		catch (Exception ex)
		{
			Console.WriteLine(ex.Message);
		}
	}

	private void ResetSudoku()
	{
		if (sudoku != null)
		{
			sudoku.Reset();
		}
	}

	private void SolveSudoku()
	{
		if (sudoku != null)
		{
			sudoku.UncoverSolution();
		}
	}

	private async void GetResult()
	{
		if (sudoku != null)
		{
			if (sudoku.IsCorrectSoulution())
			{
				await DisplayAlert("Correct Solution!");
				Console.WriteLine("Correct Solution!");
			}
			else
			{
				await DisplayAlert("Wrong Solution!");
				Console.WriteLine("Wrong Solution!");
			}
		}
	}

	private void GetHint()
	{
		if(sudoku != null)
		{
			sudoku.UncoverRandomField();
		}
	}

	private async void Start()
	{
		if (sudoku != null)
		{
			if (sudokuSolver.IsSudokuPossible(sudoku))
			{
				//start generate solution in background
				sudokuSolver.GenerateSolution(sudoku);
			}
			else
			{
				await DisplayAlert("Sudoku not possible to solve (dublicate in collumn, row or block)!");
				Console.WriteLine("Sudoku not possible to solve (dublicate in collumn, row or block)!");
			}
		}
	}
	#endregion
}

