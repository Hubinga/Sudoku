@using Sudoku.Classes;
@using Sudoku.Classes.Enums;
@using Sudoku.Classes.Structs;
@using Sudoku.Models;
@inject SweetAlertService Swal;
@inherits OwningComponentBase<DbService>
<div class="sudoku-inputs">
	@{
		if (HasUploadFileField)
		{
			<div hidden = "@(Sudoku!=null && !Sudoku.Solved)">
				<h1>Upload a sudoku to start!</h1>
				<label>
					Upload a sudoku:
					<InputFile class="button-purple" OnChange="@OnInputFileChanged"/>
				</label>
			</div>
			<br/>
		}
	}
	<button class="button-purple" hidden ="@(Sudoku?.Solved ?? true)" disabled="@(!inactive)" @onclick="Start">Start</button>
	<button class="button-purple" hidden="@inactive" @onclick="ResetSudoku">Reset</button>
	<button class="button-purple" hidden="@inactive" disabled="@(!Sudoku?.SolvingProzessFinished)" @onclick="GetHint">Hint</button>
	<button class="button-purple" hidden="@inactive" disabled="@(!Sudoku?.SolvingProzessFinished)" @onclick="GetResult">End</button>
	<button class="button-purple" hidden="@inactive" disabled="@(!Sudoku?.SolvingProzessFinished)" @onclick="Save">Save</button>
	<br/>
</div>
<div hidden ="@(!isRunning)" class="timer-container">Time: @timeSpan.ToString(@"hh\:mm\:ss")</div>
<section class="board">
	@{
		if (Sudoku != null)
		{
			for (int i = 0; i < Sudoku.Board.GetLength(0); i++)
			{
				for (int j = 0; j < Sudoku.Board.GetLength(1); j++)
				{
					int currentRowIdx = i;
					int currentColIdx = j;
					string cssClassTag = "tile";

					if(Sudoku.IsInitialFieldStateFilled(i, j))
					{
						cssClassTag += " fieldInitialFilled";
					}

					if ((i + 1) % 3 == 0)
					{
						cssClassTag += " tile-blockRow";
					}
					if ((j + 1) % 3 == 0)
					{
						cssClassTag += " tile-blockCol";
					}
					if (i == 0)
					{
						cssClassTag += " tile-firstRow";
					}
					if (j == 0)
					{
						cssClassTag += " tile-firstCol";
					}
					int currentField = Sudoku.Board[i, j];
					string field = currentField == 0 ? " " : currentField.ToString();

					<div tabindex="-1" @onkeydown="KeyboardEventHandler" class=@cssClassTag @onclick="() => FieldClicked(currentRowIdx, currentColIdx)">@field</div>
				}
			}
		}
	}
</section>

@code {
	private SudokuCreator sudokuCreator = new SudokuCreator();
	private SudokuSolver sudokuSolver = new SudokuSolver();

	private Field activeField = new Field(-1, -1);
	private bool inactive = true;

	[Parameter]
	public Sudoku? Sudoku { get; set; } = null;
	[Parameter]
	public bool HasUploadFileField { get; set; } = true;
	[Parameter]
	public int CurrentSudokuModelId { get; set; } = -1;
	[Parameter]
	public int CurrentTime { get; set; } = 0;
	[Parameter]
	public Difficulty CurrentDifficulty { get; set; } = Difficulty.Medium;
	[Parameter]
	public HelpTypes CurrentHelp { get; set; } = HelpTypes.Nothing;

	private void ResetParameters()
	{
		CurrentSudokuModelId = -1;
		CurrentHelp = HelpTypes.Nothing;
		CurrentTime = 0;
	}

	#region Board Methods

	//change number of selected field
	private void KeyboardEventHandler(KeyboardEventArgs args)
	{
		if (Sudoku != null && activeField.RowIdx != -1 && activeField.ColIdx != -1)
		{
			if (Sudoku.Solved)
			{
				return;
			}

			string key = args.Key;

			//Console.WriteLine("Key Pressed is " + key);
			//Console.WriteLine("Event Type " + args.Type);

			//clear field
			if (key == "Backspace")
			{
				Sudoku.ChangeNumberOfField(activeField.RowIdx, activeField.ColIdx, 0);
				return;
			}

			int inputNumber;
			if (int.TryParse(key, out inputNumber))
			{
				Sudoku.ChangeNumberOfField(activeField.RowIdx, activeField.ColIdx, Convert.ToInt32(args.Key));
			}
		}
	}

	//set selected field
	private void FieldClicked(int rowIdx, int colIdx)
	{
		if (Sudoku != null && !inactive)
		{
			//Console.WriteLine("rowIdx: {0}, colIdx: {1}", rowIdx, colIdx);
			//avoid changing field if its initially filled
			if (Sudoku.IsInitialFieldStateFilled(rowIdx, colIdx))
			{
				//Console.WriteLine("Can't change field value if its initialy filled");
				activeField.RowIdx = -1;
				activeField.ColIdx = -1;
			}
			else
			{
				activeField.RowIdx = rowIdx;
				activeField.ColIdx = colIdx;
			}
		}
	}
	#endregion

	#region Button Methods

	//upload sudoku
	private async Task OnInputFileChanged(InputFileChangeEventArgs e)
	{
		//text file
		if (e.File.ContentType != "text/plain")
		{
			return;
		}

		var file = e.File;
		long maxsize = 512000;

		var buffer = new byte[file.Size];
		await file.OpenReadStream(maxsize).ReadAsync(buffer);
		string fileContent = System.Text.Encoding.UTF8.GetString(buffer);

		try
		{
			Sudoku = sudokuCreator.GenerateSudokuFromFile(fileContent);
			activeField.ResetField();
		}
		catch (Exception ex)
		{
			await AlertBox.DisplayAlert(Swal,ex.Message);
			Console.WriteLine(ex.Message);
		}
	}

	private void ResetSudoku()
	{
		if (Sudoku != null)
		{
			Sudoku.Reset();
			//reset time to 0 (user resets the board and so the time should also start at 0)
			CurrentTime = 0;
			ResetStopwatch();
			StartStopwatch();
			//reset Help to "No Help"
			CurrentHelp = HelpTypes.Nothing;
		}
	}

	private async void SolveSudoku()
	{
		if (Sudoku != null)
		{
			try
			{
				Sudoku.TryUncoverSolution();
				CurrentHelp = HelpTypes.Solution;
			}
			catch (Exception e)
			{
				await AlertBox.DisplayError(Swal, e.Message);
				Console.WriteLine(e.Message);
			}
		}
	}

	private async void GetResult()
	{
		if (Sudoku != null)
		{
			try
			{
				if (Sudoku.IsCorrectSoulution())
				{
					StopSudokuProzess();
					await AlertBox.DisplayAlert(Swal, "Correct Solution!\n Your time: " + (int)timeInSeconds + " seconds");
					//save
					await Save();
					ResetParameters();
					InvokeAsync(StateHasChanged);
				}
				else
				{
					//pause
					StopStopwatch();
					var result = await AlertBox.DisplayAlertWithButtons(Swal, "Wrong Solution! Continue or Cancel?", "Continue", "Show Solution");

					//continue
					if (!string.IsNullOrEmpty(result.Value))
					{
						StartStopwatch();
					}
					//end
					else
					{
						SolveSudoku();
						StopSudokuProzess();
						//save
						await Save();
						ResetParameters();
						InvokeAsync(StateHasChanged);
					}
				}
			}
			catch (Exception e)
			{
				await AlertBox.DisplayError(Swal, e.Message);
			}
		}
	}

	private void StopSudokuProzess()
	{
		ResetStopwatch();
		inactive = true;
		Sudoku.Solved = true;
	}

	private async void GetHint()
	{
		if (Sudoku != null)
		{
			try
			{
				Sudoku.TryUncoverRandomField();
				CurrentHelp = HelpTypes.Hints;
			}
			catch (TryUncoverRandomFieldException e)
			{
				await AlertBox.DisplayAlert(Swal, e.Message);
			}
			catch (Exception e)
			{
				await AlertBox.DisplayError(Swal, e.Message);
			}
		}
	}

	private async void Start()
	{
		if (Sudoku != null)
		{
			if (sudokuSolver.IsSudokuPossible(Sudoku))
			{
				var action = new Action(() =>
				{
					sudokuSolver.GenerateSolution(Sudoku);
				});

				Task generateSolutionTask = new Task(action);
				//start generate solution in background
				generateSolutionTask.Start();

				StartStopwatch();
				inactive = false;
			}
			else
			{
				await AlertBox.DisplaySudokuNotPossibleAlert(Swal);
			}
		}
	}

	private async Task Save()
	{
		if (Sudoku != null)
		{
			//sudoku should not be saved, if it is not possible
			if (!sudokuSolver.IsSudokuPossible(Sudoku))
			{
				await AlertBox.DisplayError(Swal, "Sudoku cant be saved, if it contains errors (fix them or reset the sudoku before saving it!)");
				return;
			}

			SudokuModel sudokuModel = new SudokuModel();
			sudokuModel.Time = timeInSeconds > 0 ? (int)timeInSeconds : (int)timeSpan.TotalSeconds;
			sudokuModel.CurrentBoard = sudokuCreator.ConvertIntArrayToBoardString(Sudoku.Board);
			sudokuModel.OriginalBoard = sudokuCreator.ConvertIntArrayToBoardString(Sudoku.OriginalBoard);
			sudokuModel.Difficulty = Enum.GetName(typeof(Difficulty), CurrentDifficulty);
			sudokuModel.Help = Enum.GetName(typeof(HelpTypes), CurrentHelp);

			if (Sudoku.Solved)
			{
				sudokuModel.SolvedBoard = sudokuCreator.ConvertIntArrayToBoardString(Sudoku.SolvedBoard);
				sudokuModel.Solved = true;
			}

			//not yet saved: new entry
			if(CurrentSudokuModelId == -1)
			{
				await SaveNewEntry(sudokuModel);
			}
			//already saved: update entry
			else
			{
				//set Id of sudoku model to update
				sudokuModel.Id = CurrentSudokuModelId;
				await SaveExistingEntry(sudokuModel);
			}
		}
	}

	private async Task SaveNewEntry(SudokuModel sudokuModel)
	{
		var result = @Service.AddSudokuModelAsync(sudokuModel);

		if (result != null)
		{
			await AlertBox.DisplayAlert(Swal, "Sudoku successfully saved!");
			CurrentSudokuModelId = result.Result;
		}
		else
		{
			await AlertBox.DisplayError(Swal, "Error while saving sudoku!");
		}
	}

	private async Task SaveExistingEntry(SudokuModel sudokuModel)
	{
		var result = @Service.UpdateSudokuModelAsync(sudokuModel);

		if(result != null)
		{
			if (result.Result)
			{
				await AlertBox.DisplayAlert(Swal, "Sudoku successfully updated!");
			}
			else
			{
				await AlertBox.DisplayError(Swal, "Error while updating sudoku!");
			}
		}
		else
		{
			await AlertBox.DisplayError(Swal, "Error while updating sudoku!");
		}
	}

	#endregion

	#region StopWatch Component
	private TimeSpan timeSpan;
	private bool isRunning = false;
	private DateTime startTime;
	private Timer timer;
	private double timeInSeconds;

	private void StartStopwatch()
	{
		if (!isRunning)
		{
			if(timeSpan == TimeSpan.Zero)
			{
				timeSpan = TimeSpan.FromSeconds(CurrentTime);
			}

			startTime = DateTime.Now - timeSpan;
			timer = new Timer(UpdateTime, null, 0, 1000);
			timeInSeconds = 0;
			isRunning = true;
		}
	}

	private void UpdateTime(object state)
	{
		timeSpan = DateTime.Now - startTime;
		InvokeAsync(StateHasChanged);
	}

	private void StopStopwatch()
	{
		if (isRunning)
		{
			timer?.Dispose();
			isRunning = false;
		}
	}

	private void ResetStopwatch()
	{
		StopStopwatch();
		timeInSeconds = timeSpan.TotalSeconds;
		timeSpan = TimeSpan.Zero;
	}
	#endregion
}

