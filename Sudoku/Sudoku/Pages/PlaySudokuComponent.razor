@using Sudoku.Classes;
@using Sudoku.Models;
@inject SweetAlertService Swal;
@inherits OwningComponentBase<DbService>
<div class="sudoku-inputs">
	<div hidden = "@(sudoku!=null && !sudoku.Solved)">
		<h1>Upload a sudoku to start!</h1>
		<label>
			Upload a sudoku:
			<InputFile class="button-purple" OnChange="@OnInputFileChanged"/>
		</label>
	</div>
	<br/>
	<button class="button-purple" hidden ="@(sudoku==null)" disabled="@(!inactive)" @onclick="Start">Start</button>
	<button class="button-purple" hidden="@inactive" @onclick="ResetSudoku">Reset</button>
	<button class="button-purple" hidden="@inactive" disabled="@(!sudoku?.SolvingProzessFinished)" @onclick="GetHint">Hint</button>
	<button class="button-purple" hidden="@inactive" disabled="@(!sudoku?.SolvingProzessFinished)" @onclick="GetResult">End</button>
	<button class="button-purple" hidden="@inactive" disabled="@(!sudoku?.SolvingProzessFinished)" @onclick="Save">Save</button>
	<br/>
</div>
<div hidden ="@(!isRunning)" class="timer-container">Time: @timeSpan.ToString(@"hh\:mm\:ss")</div>
<section class="board">
	@{
		if (sudoku != null)
		{
			for (int i = 0; i < sudoku.Board.GetLength(0); i++)
			{
				for (int j = 0; j < sudoku.Board.GetLength(1); j++)
				{
					int currentRowIdx = i;
					int currentColIdx = j;
					string cssClassTag = "tile";

					if (i == 0)
					{
						cssClassTag += " tile-firstRow";
					}
					if (j == 0)
					{
						cssClassTag += " tile-firstCol";
					}

					<div tabindex="-1" @onkeydown="KeyboardEventHandler" class=@cssClassTag @onclick="() => FieldClicked(currentRowIdx, currentColIdx)">@sudoku.Board[i, j]</div>
				}
			}
		}
	}
</section>

@code {
	private struct Field
	{
		public int RowIdx;
		public int ColIdx;

		public Field(int rowIdx, int colIdx)
		{
			RowIdx = rowIdx;
			ColIdx = colIdx;
		}
	}

	private SudokuCreator sudokuCreator = new SudokuCreator();
	private SudokuSolver sudokuSolver = new SudokuSolver();
	private Sudoku? sudoku = null;

	private Field activeField = new Field(-1, -1);

	private bool inactive = true;

	#region Helper Methods

	#endregion

	#region Board Methods

	//change number of selected field
	private void KeyboardEventHandler(KeyboardEventArgs args)
	{
		if (sudoku != null && activeField.RowIdx != -1 && activeField.ColIdx != -1)
		{
			string key = args.Key;

			//Console.WriteLine("Key Pressed is " + key);
			//Console.WriteLine("Event Type " + args.Type);

			int inputNumber;
			if (int.TryParse(key, out inputNumber))
			{
				sudoku.ChangeNumberOfField(activeField.RowIdx, activeField.ColIdx, Convert.ToInt32(args.Key));
			}
		}
	}

	//set selected field
	private void FieldClicked(int rowIdx, int colIdx)
	{
		if (sudoku != null && !inactive)
		{
			//Console.WriteLine("rowIdx: {0}, colIdx: {1}", rowIdx, colIdx);
			//avoid changing field if its initially filled
			if (sudoku.IsInitialFieldStateFilled(rowIdx, colIdx))
			{
				//Console.WriteLine("Can't change field value if its initialy filled");
				activeField.RowIdx = -1;
				activeField.ColIdx = -1;
			}
			else
			{
				activeField.RowIdx = rowIdx;
				activeField.ColIdx = colIdx;
			}
		}
	}
	#endregion

	#region Button Methods

	//upload sudoku
	private async Task OnInputFileChanged(InputFileChangeEventArgs e)
	{
		//check for file type

		var file = e.File;
		long maxsize = 512000;

		var buffer = new byte[file.Size];
		await file.OpenReadStream(maxsize).ReadAsync(buffer);
		string fileContent = System.Text.Encoding.UTF8.GetString(buffer);

		try
		{
			sudoku = sudokuCreator.LoadFromFile(fileContent);
			//await AlertBox.DisplayAlert(Swal, "Press start and try to solve it!");
		}
		catch (Exception ex)
		{
			await AlertBox.DisplayAlert(Swal,ex.Message);
			Console.WriteLine(ex.Message);
		}
	}

	private void ResetSudoku()
	{
		if (sudoku != null)
		{
			sudoku.Reset();
		}
	}

	private async void SolveSudoku()
	{
		if (sudoku != null)
		{
			try
			{
				sudoku.TryUncoverSolution();
			}
			catch (Exception e)
			{
				await AlertBox.DisplayAlert(Swal, e.Message);
				Console.WriteLine(e.Message);
			}
		}
	}

	private async void GetResult()
	{
		if (sudoku != null)
		{
			try
			{
				if (sudoku.IsCorrectSoulution())
				{
					StopSudokuProzess();
					await AlertBox.DisplayAlert(Swal, "Correct Solution!\n Your time: " + (int)timeInSeconds + " seconds");
					//save
					await Save();
					sudoku = null;
					InvokeAsync(StateHasChanged);
				}
				else
				{
					//pause
					StopStopwatch();
					var result = await AlertBox.DisplayAlertWithButtons(Swal, "Wrong Solution! Continue or Cancel?", "Continue", "Show Solution");

					//continue
					if (!string.IsNullOrEmpty(result.Value))
					{
						StartStopwatch();
					}
					//end
					else
					{
						SolveSudoku();
						StopSudokuProzess();
						//save
						await Save();
						InvokeAsync(StateHasChanged);
					}
				}
			}
			catch (Exception e)
			{
				await AlertBox.DisplayError(Swal, e.Message);
			}
		}
	}

	private void StopSudokuProzess()
	{
		ResetStopwatch();
		inactive = true;
		sudoku.Solved = true;
	}

	private async void GetHint()
	{
		if (sudoku != null)
		{
			try
			{
				sudoku.TryUncoverRandomField();
			}
			catch (Exception e)
			{
				await AlertBox.DisplayError(Swal, e.Message);
			}
		}
	}

	private async void Start()
	{
		if (sudoku != null)
		{
			if (sudokuSolver.IsSudokuPossible(sudoku))
			{
				var action = new Action(() =>
				{
					sudokuSolver.GenerateSolution(sudoku);
				});

				Task generateSolutionTask = new Task(action);
				//start generate solution in background
				generateSolutionTask.Start();

				StartStopwatch();
				inactive = false;
			}
			else
			{
				await AlertBox.DisplayAlert(Swal, "Sudoku not possible to solve (dublicate in collumn, row or block)!");
			}
		}
	}

	int currentSudokuModelId = -1;

	private async Task Save()
	{
		if (sudoku != null)
		{
			SudokuModel sudokuModel = new SudokuModel();
			sudokuModel.Time = timeInSeconds > 0 ? (int)timeInSeconds : (int)timeSpan.TotalSeconds;
			sudokuModel.CurrentBoard = sudokuCreator.ConvertIntArrayToBoardString(sudoku.Board);
			sudokuModel.OriginalBoard = sudokuCreator.ConvertIntArrayToBoardString(sudoku.OriginalBoard);
			sudokuModel.Difficulty = "Medium";

			if (sudoku.Solved)
			{
				sudokuModel.SolvedBoard = sudokuCreator.ConvertIntArrayToBoardString(sudoku.SolvedBoard);
				sudokuModel.Solved = true;
			}

			//not yet saved: new entry
			if(currentSudokuModelId == -1)
			{
				await SaveNewEntry(sudokuModel);
			}
			//already saved: update entry
			else
			{
				//set Id of sudoku model to update
				sudokuModel.Id = currentSudokuModelId;
				await SaveExistingEntry(sudokuModel);
			}
		}
	}

	private async Task SaveNewEntry(SudokuModel sudokuModel)
	{
		var result = @Service.AddSudokuModelAsync(sudokuModel);

		if (result != null)
		{
			await AlertBox.DisplayAlert(Swal, "Sudoku successfully saved!");
			currentSudokuModelId = result.Result;
		}
		else
		{
			await AlertBox.DisplayError(Swal, "Error while saving sudoku!");
		}
	}

	private async Task SaveExistingEntry(SudokuModel sudokuModel)
	{
		var result = @Service.UpdateSudokuModelAsync(sudokuModel);

		if(result != null)
		{
			if (result.Result)
			{
				await AlertBox.DisplayAlert(Swal, "Sudoku successfully updated!");
			}
			else
			{
				await AlertBox.DisplayError(Swal, "Error while updating sudoku!");
			}
		}
		else
		{
			await AlertBox.DisplayError(Swal, "Error while updating sudoku!");
		}
	}

	#endregion

	#region StopWatch Component
	private TimeSpan timeSpan;
	private bool isRunning = false;
	private DateTime startTime;
	private Timer timer;
	private double timeInSeconds;

	private void StartStopwatch()
	{
		if (!isRunning)
		{
			startTime = DateTime.Now - timeSpan;
			timer = new Timer(UpdateTime, null, 0, 1000);
			timeInSeconds = 0;
			isRunning = true;
		}
	}

	private void UpdateTime(object state)
	{
		timeSpan = DateTime.Now - startTime;
		InvokeAsync(StateHasChanged);
	}

	private void StopStopwatch()
	{
		if (isRunning)
		{
			timer?.Dispose();
			isRunning = false;
		}
	}

	private void ResetStopwatch()
	{
		StopStopwatch();
		timeInSeconds = timeSpan.TotalSeconds;
		timeSpan = TimeSpan.Zero;
	}
	#endregion
}

