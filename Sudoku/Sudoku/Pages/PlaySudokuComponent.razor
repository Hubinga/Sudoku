@using Sudoku.Classes;
@using Sudoku.Classes.Enums;
@using Sudoku.Components
@using Sudoku.Models;
@inject SweetAlertService Swal;
@inherits OwningComponentBase<DbService>
<div class="sudoku-inputs">
	@{
		if (HasUploadFileField)
		{
			<div hidden = "@(sudoku!=null && !sudoku.Solved)">
				<h1>Upload a sudoku to start!</h1>
					<InputFile class="button-purple" OnChange="@OnInputFileChanged"/>
			</div>
			<br/>
		}
	}
	<button class="button-purple" hidden="@(sudoku?.Solved ?? false)" disabled="@(!inactive)" @onclick="Start" title="Start Solving the Sudoku">Start</button>
	<button class="button-purple" hidden="@inactive" @onclick="ResetSudoku" title="Reset Board to initial State">Reset</button>
	<button class="button-purple" hidden="@inactive" disabled="@(!sudoku?.SolvingProzessFinished)" @onclick="GetHint" title="Uncover random field!">Hint</button>
	<button class="button-purple" hidden="@inactive" disabled="@(!sudoku?.SolvingProzessFinished)" @onclick="GetResult" title="Get Result!">End</button>
	<button class="button-purple" hidden="@inactive" disabled="@(!sudoku?.SolvingProzessFinished)" @onclick="Save" title="Save current Sudoku!">Save</button>
	<button class="button-purple" hidden="@(SudokuData != null)" disabled="@(!sudoku?.SolvingProzessFinished)" @onclick="Restart" title="Restart with an empty Board!">Restart</button>
	<br/>
</div>
<div hidden ="@(!isRunning)" class="timer-container">Time: @timeSpan.ToString(@"hh\:mm\:ss")</div>
<BoardComponent Board="Board" Edit="BoardCanBeEdit()" InitialFilledFields="initialFilledFields"></BoardComponent>

@code {
	private SudokuCreator sudokuCreator = new SudokuCreator();
	private SudokuSolver sudokuSolver = new SudokuSolver();

	private bool inactive = true;
	private Sudoku? sudoku = null;

	private List<Tuple<int, int>> initialFilledFields { get; set; } = new List<Tuple<int, int>>();

	[Parameter]
	public int[,] Board { get; set; }  = new int[9, 9];
	[Parameter]
	public SudokuData? SudokuData { get; set; } = null; 
	[Parameter]
	public bool HasUploadFileField { get; set; } = true;
	[Parameter]
	public int CurrentSudokuModelId { get; set; } = -1;
	[Parameter]
	public int CurrentTime { get; set; } = 0;
	[Parameter]
	public Difficulty CurrentDifficulty { get; set; } = Difficulty.Medium;
	[Parameter]
	public HelpTypes CurrentHelp { get; set; } = HelpTypes.Nothing;

	private void ResetParameters()
	{
		CurrentSudokuModelId = -1;
		CurrentHelp = HelpTypes.Nothing;
		CurrentTime = 0;
	}

	private bool BoardCanBeEdit()
	{
		//load model (user should not be able to modify board before pressing start)
		if (SudokuData != null)
		{
			return !inactive;
		}
		else
		{
			return !sudoku?.Solved ?? true;
		}
	}

	#region Button Methods
	//Upload Sudoku Button
	private async Task OnInputFileChanged(InputFileChangeEventArgs e)
	{
		//text file
		if (e.File.ContentType != "text/plain")
		{
			return;
		}

		var file = e.File;
		long maxsize = 512000;

		var buffer = new byte[file.Size];
		await file.OpenReadStream(maxsize).ReadAsync(buffer);
		string fileContent = System.Text.Encoding.UTF8.GetString(buffer);

		try
		{
			Board = sudokuCreator.LoadBoardFromFile(fileContent);
			//display start button again without pressing the restart button
			sudoku = null;
		}
		catch (Exception ex)
		{
			await AlertBox.DisplayAlert(Swal,ex.Message);
			Console.WriteLine(ex.Message);
		}
	}

	//Reset Button
	private void ResetSudoku()
	{
		if (sudoku != null)
		{
			//reset current board to original board
			sudoku.Reset();
			//reset time to 0 (user resets the board and so the time should also start at 0)
			CurrentTime = 0;
			ResetStopwatch();
			StartStopwatch();
			//reset Help to "No Help"
			CurrentHelp = HelpTypes.Nothing;
		}
	}

	#region End
	//End Button
	private async void GetResult()
	{
		if (sudoku != null)
		{
			try
			{
				if (sudoku.IsCorrectSoulution())
				{
					StopSudokuProzess();
					await AlertBox.DisplayAlert(Swal, "Correct Solution!\n Your time: " + (int)timeInSeconds + " seconds");
					//save
					await Save();
					ResetParameters();
					InvokeAsync(StateHasChanged);
				}
				else
				{
					//pause
					StopStopwatch();
					var result = await AlertBox.DisplayAlertWithButtons(Swal, "Wrong Solution! Continue or Cancel?", "Continue", "Show Solution");

					//continue
					if (!string.IsNullOrEmpty(result.Value))
					{
						StartStopwatch();
					}
					//end
					else
					{
						DisplaySolution();
						StopSudokuProzess();
						//save
						await Save();
						ResetParameters();
						InvokeAsync(StateHasChanged);
					}
				}
			}
			catch (Exception e)
			{
				await AlertBox.DisplayError(Swal, e.Message);
			}
		}
	}

	private async void DisplaySolution()
	{
		if (sudoku != null)
		{
			try
			{
				//display solved board
				sudoku.TryUncoverSolution();
				CurrentHelp = HelpTypes.Solution;
			}
			catch (Exception e)
			{
				await AlertBox.DisplayError(Swal, e.Message);
			}
		}
	}

	//Sudoku is solved: end "game"
	private void StopSudokuProzess()
	{
		ResetStopwatch();
		inactive = true;
		sudoku.Solved = true;
		initialFilledFields.Clear();
	}
	#endregion

	//Hint Button
	private async void GetHint()
	{
		if (sudoku != null)
		{
			try
			{
				sudoku.TryUncoverRandomField();
				CurrentHelp = HelpTypes.Hints;
			}
			catch (TryUncoverRandomFieldException e)
			{
				await AlertBox.DisplayAlert(Swal, e.Message);
			}
			catch (Exception e)
			{
				await AlertBox.DisplayError(Swal, e.Message);
			}
		}
	}

	//Start Button
	private async void Start()
	{
		if (sudoku == null)
		{		
			if(SudokuData != null)
			{
				//load sudoku
				sudoku = new Sudoku(SudokuData.OriginalBoard, SudokuData.CurrentBoard, SudokuData.SolvedBoard, SudokuData.Solved);	
			}
			else
			{
				//new sudoku
				sudoku = new Sudoku(Board);
			}

			if (sudokuSolver.IsSudokuPossible(sudoku))
			{
				//store initial filled fields
				initialFilledFields = sudoku.GetInitialFilledFields();

				var action = new Action(() =>
				{
					sudokuSolver.GenerateSolution(sudoku);
				});

				Task generateSolutionTask = new Task(action);
				//start generate solution in background
				generateSolutionTask.Start();

				StartStopwatch();
				inactive = false;
			}
			else
			{
				sudoku = null;
				await AlertBox.DisplaySudokuNotPossibleAlert(Swal);
			}
		}
	}

	//Restart Button (start with empty board)
	private async Task Restart()
	{
		Board = new int[Board.GetLength(0), Board.GetLength(1)];
		sudoku = null;
		inactive = true;
		//reset time to 0 (user resets the board and so the time should also start at 0)
		CurrentTime = 0;
		ResetStopwatch();
		//reset Help to "No Help"
		CurrentHelp = HelpTypes.Nothing;
	}
	
	#region Save
	//Save Button
	private async Task Save()
	{
		if (sudoku != null)
		{
			//sudoku should not be saved, if it is not possible
			if (!sudokuSolver.IsSudokuPossible(sudoku))
			{
				await AlertBox.DisplayError(Swal, "Sudoku cant be saved, if it contains errors (fix them or reset the sudoku before saving it!)");
				return;
			}

			SudokuModel sudokuModel = new SudokuModel();
			sudokuModel.Time = timeInSeconds > 0 ? (int)timeInSeconds : (int)timeSpan.TotalSeconds;
			sudokuModel.CurrentBoard = sudokuCreator.ConvertIntArrayToBoardString(sudoku.Board);
			sudokuModel.OriginalBoard = sudokuCreator.ConvertIntArrayToBoardString(sudoku.OriginalBoard);
			sudokuModel.Difficulty = Enum.GetName(typeof(Difficulty), CurrentDifficulty);
			sudokuModel.Help = Enum.GetName(typeof(HelpTypes), CurrentHelp);

			if (sudoku.Solved)
			{
				sudokuModel.SolvedBoard = sudokuCreator.ConvertIntArrayToBoardString(sudoku.SolvedBoard);
				sudokuModel.Solved = true;
			}

			//not yet saved: new entry
			if(CurrentSudokuModelId == -1)
			{
				await SaveNewEntry(sudokuModel);
			}
			//already saved: update entry
			else
			{
				//set Id of sudoku model to update
				sudokuModel.Id = CurrentSudokuModelId;
				await SaveExistingEntry(sudokuModel);
			}
		}
	}

	private async Task SaveNewEntry(SudokuModel sudokuModel)
	{
		var result = @Service.AddSudokuModelAsync(sudokuModel);

		if (result != null)
		{
			await AlertBox.DisplayAlert(Swal, "Sudoku successfully saved!");
			CurrentSudokuModelId = result.Result;
		}
		else
		{
			await AlertBox.DisplayError(Swal, "Error while saving sudoku!");
		}
	}

	private async Task SaveExistingEntry(SudokuModel sudokuModel)
	{
		var result = @Service.UpdateSudokuModelAsync(sudokuModel);

		if(result != null)
		{
			if (result.Result)
			{
				await AlertBox.DisplayAlert(Swal, "Sudoku successfully updated!");
			}
			else
			{
				await AlertBox.DisplayError(Swal, "Error while updating sudoku!");
			}
		}
		else
		{
			await AlertBox.DisplayError(Swal, "Error while updating sudoku!");
		}
	}

	#endregion

	#endregion

	#region StopWatch Component
	private TimeSpan timeSpan;
	private bool isRunning = false;
	private DateTime startTime;
	private Timer timer;
	private double timeInSeconds;

	private void StartStopwatch()
	{
		if (!isRunning)
		{
			if(timeSpan == TimeSpan.Zero)
			{
				timeSpan = TimeSpan.FromSeconds(CurrentTime);
			}

			startTime = DateTime.Now - timeSpan;
			timer = new Timer(UpdateTime, null, 0, 1000);
			timeInSeconds = 0;
			isRunning = true;
		}
	}

	private void UpdateTime(object state)
	{
		timeSpan = DateTime.Now - startTime;
		InvokeAsync(StateHasChanged);
	}

	private void StopStopwatch()
	{
		if (isRunning)
		{
			timer?.Dispose();
			isRunning = false;
		}
	}

	private void ResetStopwatch()
	{
		StopStopwatch();
		timeInSeconds = timeSpan.TotalSeconds;
		timeSpan = TimeSpan.Zero;
	}
	#endregion
}

