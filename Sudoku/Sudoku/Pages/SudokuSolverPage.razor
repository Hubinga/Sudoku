@page "/SudokuSolver"
@using Sudoku.Classes;
@using Sudoku.Components
@inject SweetAlertService Swal;
<h1>Enter the known numbers or upload a sudoku and click the Solve button!</h1>
<div>
	<InputFile class="button-purple" OnChange="@OnInputFileChanged"/>
</div>
<br/>
@{
	if(board != null)
	{
		<button class="button-purple" @onclick="Reset" title="Reset to an empty Board!">Reset</button>
		<button class="button-purple" @onclick="Solve" title="Solve Board!">Solve</button>
		<button class="button-purple" @onclick="Unsolve" title="Restore Unsolved Board!">Unsolve</button>
		<br/>

		<div id="gallerywrapper">
			<div id="gallery">
				<div id="pic1">
					<BoardComponent Board="board" Edit="@(boardSolutuions == null)"></BoardComponent>

					@if (boardSolutuions != null)
					{
						<button class="button-purple previous" @onclick="Prev" title="Show previous Solution!">Prev</button>
						<button class="button-purple next" @onclick="Next" title="Show next Solution!">Next</button>
						<h3>Solution @(currentBoardSolutuionIdx + 1) of @boardSolutuions?.Count</h3>
					}
				</div>
			</div>
		</div>
	}
}

@code {

	private int[,] board = new int[9,9];
	private int[,]? boardBeforeSolving = null;

	private List<int[,]>? boardSolutuions = null;
	private int currentBoardSolutuionIdx = -1;

	private SudokuCreator sudokuCreator = new SudokuCreator();
	private SudokuSolver sudokuSolver = new SudokuSolver();

	private int numberOfSolutions = 10;

	//Reset Button -> start with an empty board
	private void Reset()
	{
		board = new int[board.GetLength(0), board.GetLength(1)];
		boardBeforeSolving = null;
		boardSolutuions = null;
		currentBoardSolutuionIdx = -1;
	}

	private async Task OnInputFileChanged(InputFileChangeEventArgs e)
	{
		//text file
		if (e.File.ContentType != "text/plain")
		{
			return;
		}

		var file = e.File;
		long maxsize = 512000;

		var buffer = new byte[file.Size];
		await file.OpenReadStream(maxsize).ReadAsync(buffer);
		string fileContent = System.Text.Encoding.UTF8.GetString(buffer);

		try
		{
			board = sudokuCreator.LoadBoardFromFile(fileContent);
		}
		catch (Exception ex)
		{
			await AlertBox.DisplayAlert(Swal, ex.Message);
			Console.WriteLine(ex.Message);
		}
	}

	//Solve Button: Display solved Board
	private async void Solve()
	{
		try
		{
			Sudoku sudoku = new Sudoku(board);

			if (sudokuSolver.IsSudokuPossible(sudoku))
			{
				//store original board to restore (unsolve) it later
				boardBeforeSolving = new int[board.GetLength(0), board.GetLength(1)];
				Array.Copy(board, boardBeforeSolving, board.Length);
				//solving prozess
				sudokuSolver.GenerateSolution(sudoku, numberOfSolutions);
				//get all solutions
				boardSolutuions = sudoku.BoardSolutions;
				
				if(boardSolutuions.Count > 0)
				{
					//for testing
					HasDublicateSolutions();
					//set solution idx to first element (0)
					currentBoardSolutuionIdx = 0;
					//display first solution
					board = boardSolutuions[0];
				}
			}
			else
			{
				await AlertBox.DisplaySudokuNotPossibleAlert(Swal);
			}
		}
		catch (Exception e)
		{
			await AlertBox.DisplayError(Swal, e.Message);
		}
	}

	//Unsolve Button: restore original board
	private void Unsolve()
	{
		if(boardBeforeSolving != null)
		{
			Array.Copy(boardBeforeSolving, board, boardBeforeSolving.Length);
			boardBeforeSolving = null;
			boardSolutuions = null;
			currentBoardSolutuionIdx = -1;
		}
	}

	private void Next()
	{
		if(boardSolutuions != null)
		{
			if(currentBoardSolutuionIdx < boardSolutuions.Count - 1)
			{
				currentBoardSolutuionIdx++;
			}
			else
			{
				currentBoardSolutuionIdx = 0;
			}
			board = boardSolutuions[currentBoardSolutuionIdx];
		}
	}

	private void Prev()
	{
		if (boardSolutuions != null)
		{
			if(currentBoardSolutuionIdx > 0)
			{
				currentBoardSolutuionIdx--;
			}
			else
			{
				currentBoardSolutuionIdx = boardSolutuions.Count - 1;
			}
			board = boardSolutuions[currentBoardSolutuionIdx];
		}
	}

	//Only for testing
	#region Check for dublicate Solution
	private bool HasDublicateSolutions()
	{
		if (boardSolutuions != null)
		{
			//compare all boards with the first one
			for (int i = 0; i < boardSolutuions.Count; i++)
			{
				if (CheckForDublicateBoards(i))
				{
					Console.WriteLine("Dublicate Board at idx: {0}", i);
					return true;
				}
			}
		}

		Console.WriteLine("All Solutions are unique!");
		return false;
	}

	private bool CheckForDublicateBoards(int boardSolutionIdx)
	{
		if (boardSolutuions == null)
		{
			return false;
		}

		for (int currentBoardIdx = 0; currentBoardIdx < boardSolutuions.Count; currentBoardIdx++)
		{
			if (currentBoardIdx == boardSolutionIdx)
			{
				continue;
			}

			if (IsDublicate(boardSolutuions[boardSolutionIdx], boardSolutuions[currentBoardIdx]))
			{
				return true;
			}
		}

		return false;
	}

	private bool IsDublicate(int[,] board, int[,] otherBoard)
	{
		for (int i = 0; i < 9; i++)
		{
			for (int j = 0; j < 9; j++)
			{
				if (otherBoard[i, j] != board[i, j])
				{
					return false;
				}
			}
		}

		return true;
	}
	#endregion
}
